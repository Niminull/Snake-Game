<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- styles -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-dark@5.0.16/dark.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        } *::before, *::after {
            display: inline-block;
            font: normal normal normal 14px/1 FontAwesome;
            font-size: inherit;
            text-rendering: auto;
            -webkit-font-smoothing: antialiased;
        } :root {
            font-size: 62.5%;
        } body {
            font-family:
                system-ui,
                -apple-system,
                BlinkMacSystemFont,
                "Segoe UI",
                Roboto,
                Oxygen,
                Ubuntu,
                Cantarell,
                "Open Sans",
                "Helvetica Neue",
                sans-serif;
            width: 100%;
            height: 100vh;
            background: #111111;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        
        #wrapper {
            top: 0;
            left: 0;
            position: fixed;
            width: 100vw;
            height: 100vh;
            z-index: 99999;
            opacity: 0;
            visibility: hidden;
            background: #11111177;
            transition: 200ms;
        } #wrapper.active {
            opacity: 1;
            visibility: visible;
        }
        
        canvas {
            margin: 0 auto;
            padding: 0;
        }

        a, button {
            cursor: pointer;
            -webkit-tap-highlight-color: transparent !important;
        }

        /* preloader */

        .preload {
            display: flex;
            align-items: center;
            justify-content: center;
            position: fixed;
            top: 0;
            left: 0;
            color: #ffffff;
            width: 100vw;
            height: 125vh;
            margin: 0;
            padding: 0;
            z-index: 9999;
            font-size: 8vh;
            background: #111111;
            transition: 0.5s;
            letter-spacing: 0.8rem;
        } .preload.loaded {
            opacity: 0;
            visibility: hidden;
        } .preload span {
            height: 50vh;
            opacity: 0;
            display: inline-block;
            transform: rotateX(-90deg);
            text-align: center;
            text-transform: uppercase;
        } .let {
            animation: drop 3s ease-in-out infinite;
        } .let1 {
            animation-delay: 1.2s;
        } .let2 {
            animation-delay: 1.3s;
        } .let3 {
            animation-delay: 1.4s;
        } .let4 {
            animation-delay: 1.5s;
        } .let5 {
            animation-delay: 1.6s;
        } .let6 {
            animation-delay: 1.7s;
        } .let7 {
            animation-delay: 1.8s;
        } .preload.loaded span {
            animation: none;
        } @keyframes drop {
            10% {
                opacity: 0.5;
            } 20% {
                opacity: 1;
                top: 3.78rem;
                transform: rotateX(-360deg);
            } 80% {
                opacity: 1;
                top: 3.78rem;
                transform: rotateX(-360deg);
            } 90% {
                opacity: 0.5;
            } 100% {
                opacity: 0;
                top: 6.94rem;
            }
        }

        /* preload end */


        @media (max-width: 767.98px) {
            body {
                width: 100vw;
                height: 100vh;
                overflow: hidden;
            }
            canvas {
                height: auto;
                max-height: 100vh;
                border-top: 1px solid #fff4;
                border-bottom: 1px solid #fff4;
            }
        }
    </style>

    <title>Snake Game</title>
</head>
<body>
    <!-- preloader -->
    <div class="preload">
        <span class="let let1">l</span>  
        <span class="let let2">o</span>  
        <span class="let let3">a</span>  
        <span class="let let4">d</span>  
        <span class="let let5">i</span>  
        <span class="let let6">n</span>  
        <span class="let let7">g</span>  
    </div>
    <script> window.addEventListener('load', () => document.querySelector(".preload").classList.add('loaded')) </script>

    <div id="wrapper"></div>
    <canvas id="canvas"> Your browser doesn't support canvas element </canvas>

    <script>

        class Screen {

            constructor (object) {
                this.canvas     = object.canvas
                this.controller = object.controllerElement
                this.scale      = object.scale
                this.fps        = object.fps
                this.ctx;
                this.rows;
                this.columns;
            }

            init = () => {
                let width = 0, height = 0
                width = window.innerWidth - window.innerWidth % this.scale
                height = window.innerHeight - window.innerHeight % this.scale
                this.ctx = this.canvas.getContext('2d')
                this.ctx.lineWidth = 2

                if (window.innerWidth < 767.98) 
                    height = window.height - this.controller.offsetHeight - (window.height - this.controller.offsetHeight) % scale

                this.canvas.width = width
                this.canvas.height = height

                this.columns = this.canvas.width / this.scale
                this.rows = this.canvas.height / this.scale
            }

            resize = () => this.init()

            drawGridLines = (width, color) => {
                const w = width ? width: 2
                const drawColumns = (start, end) => 
                    this.ctx.fillRect( start - w / 2, 0, w, this.canvas.height) || ( start < end && drawColumns( start+this.scale, end ) )
                const drawRows = (start, end) => 
                    this.ctx.fillRect( 0, start - w / 2, this.canvas.width, w) || ( start < end && drawRows( start+this.scale, end ) )

                this.ctx.fillStyle = color ? color: '#010101'
                drawColumns(0, this.canvas.width)
                drawRows(0, this.canvas.height)
            }

            clear = () => this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)

            getFPS = () => this.fps
            getScale = () => this.scale
            getCanvas = () => this.canvas
            getRowsCount = () => this.rows
            getColsCount = () => this.columns

        }

        class Game {
            constructor (configs) {
                this.initHandler    = configs.init
                this.startHandler   = configs.start
                this.pauseHandler   = configs.pause
                this.resumeHandler  = configs.resume
                this.restartHandler = configs.restart
                this.endHandler     = configs.end
                this.saveHandler    = configs.save
                this.loadHandler    = configs.load
            }

            init    = () => this.initHandler()
            start   = () => this.startHandler()
            pause   = () => this.pauseHandler()
            resume  = () => this.resumeHandler()
            restart = () => this.restartHandler()
            isOver  = () => this.endHandler()
            save    = () => this.saveHandler()
            load    = () => this.loadHandler()

        }
        
        class Snake {

            constructor (object) {
                this.canvasId = object.canvasId
                const canvas = document.getElementById(this.canvasId)
                this.ctx    = canvas.getContext('2d')
                this.gap    = object.gap
                this.color  = object.mainColor
                this.spiritColor = object.spiritColor

                this.name   = object.name
                this.width  = object.width
                this.height = object.height

                this.body   = object.body ? object.body: []
                this.cloneBody = object.cloneBody ? object.cloneBody: []
            }

            spawn = (coordinates) => {
                this.body.push({ x: coordinates.x, y: coordinates.y })
            }

            draw = (string) => {
                if (string === 'snake') {
                    this.ctx.fillStyle = this.color
                    this.ctx.beginPath()
                    this.drawPart(this.body, 0, 4, true)
                } else if (string === 'path') {
                    this.ctx.fillStyle = this.spiritColor
                    this.ctx.beginPath()
                    this.drawPart(this.cloneBody, 0, 0, false)
                } else throw new Error('Invalid input, valid inputs are "snake" and "path"')
                this.ctx.fill()
            }

            drawPart = (body, index, roundness, _gap) => {
                const part = body[index++]
                if (!part) return
                const l = 4
                const gap = _gap && index < l ? (this.gap * index)**1.05: _gap && index >= l ? (this.gap * 4)**1.05: this.gap
                this.ctx.roundRect(
                    part.x + gap/2, 
                    part.y + gap/2, 
                    this.width - gap, 
                    this.height - gap, 
                    roundness
                )
                if (index < body.length)
                    return this.drawPart(body, index, roundness, _gap)
                return body
            }

            moveTo = (coordinates, screenWidth, screenHeight) => {
                this.cloneBody.push(this.body[0])
                this.choosePath(coordinates.x, coordinates.y, screenWidth, screenHeight)
            }

            // TODO: fix illegal moves at @choosePath function
            choosePath = (x, y, screenWidth, screenHeight) => {
                const head = this.cloneBody[0]
                let newHead
                let direction;

                // Determine the direction to move
                direction = 
                    head.x < x ? 'right': 
                    head.x > x ? 'left': 
                    head.y < y ? 'down': 
                    head.y > y ? 'up': 
                    null

                if (!direction) return

                switch (direction) {
                    case 'right':
                        newHead = { x: head.x + this.width, y: head.y, direction };
                        break;
                    case 'left':
                        newHead = { x: head.x - this.width, y: head.y, direction };
                        break;
                    case 'down':
                        newHead = { x: head.x, y: head.y + this.height, direction };
                        break;
                    case 'up':
                        newHead = { x: head.x, y: head.y - this.height, direction };
                        break;
                    default:
                        return;
                }

                newHead = this.reEnter(newHead, screenWidth, screenHeight)
                
                this.cloneBody.unshift(newHead)
                this.choosePath(x, y)

            }

            reEnter = (bodyPart, screenWidth, screenHeight) => {
                if (bodyPart.x > screenWidth - this.width) bodyPart.x = 0
                else if (bodyPart.x < 0) bodyPart.x = screenWidth - this.width
                else if (bodyPart.y > screenHeight - this.height) bodyPart.y = 0
                else if (bodyPart.y < 0) bodyPart.y = screenHeight - this.height
                return bodyPart
            }

            takeStep = () => {
                const newHead = this.cloneBody[ this.cloneBody.length-1 ]
                if (!newHead) return
                this.move(newHead)
                this.cloneBody.pop()
            }

            move = (newHead) => this.body = this.body.map((currentPart, index, array) => index ? array[ index - 1 ]: newHead)

            hasGetFood = (foodCoordinates) => {
                const head = this.body[0]
                if (head.x === foodCoordinates.x && head.y === foodCoordinates.y) return true
                return false
            }

            grow = (screenWidth, screenHeight) => {
                const lastPart = this.body[this.body.length - 1]
                let newPart
                switch (lastPart.direction) {
                    case 'right': { newPart = { x: lastPart.x - this.width, y: lastPart.y, direction: lastPart.direction } }
                        break
                    case 'left': { newPart  = { x: lastPart.x + this.width, y: lastPart.y, direction: lastPart.direction } }
                        break
                    case 'up': { newPart    = { x: lastPart.x, y: lastPart.y + this.height, direction: lastPart.direction } }
                        break
                    case 'down': { newPart  = { x: lastPart.x, y: lastPart.y - this.height, direction: lastPart.direction } }
                        break
                    default:
                        return
                }
                newPart = this.reEnter(newPart, screenWidth, screenHeight)
                this.body.push(newPart)
            }

            bitItself = () => this.bite(this.body, 2)

            bite = (body, index) => {
                const head = this.body[0]
                const part = this.body[index]
                if (!part) 
                    return false
                if (head.x === part.x && head.y === part.y) 
                    return true
                if (index+1 < body.length) 
                    return this.bite(body, index+1)
                return false
            }

            die = () => {}

            respawn = () => spawn()

            getBody = () => this.body

            getInfo = () => ({
                name: this.name, 
                canvasId: this.canvasId, 
                gap: this.gap, 
                width: this.width, 
                height: this.height, 
                mainColor: this.color, 
                spiritColor: this.spiritColor, 
                body: this.body, 
                cloneBody: this.cloneBody
            })

        }

        class Food {

            constructor (object) {
                const canvas = document.getElementById(object.canvasId)
                this.canvasId = object.canvasId
                this.ctx = canvas.getContext('2d')
                this.color = object.color
                this.outline = object.outline

                this.width = object.width
                this.height = object.height

                this.coordinates = {
                    x: object.coordinates ? object.coordinates.x: null, 
                    y: object.coordinates ? object.coordinates.y: null
                }
                
                this.flag = true
            }

            spawn = (coordinates) => {
                this.coordinates = { x: coordinates.x, y: coordinates.y }
                if (this.flag) 
                    this.coordinates = { x: this.coordinates.x,  y: this.coordinates.y }
                this.flag = false
            }

            respawn = (coordinates) => this.spawn(coordinates)

            draw = () => {                
                this.ctx.fillStyle = this.color
                this.ctx.beginPath()
                this.ctx.roundRect(
                    this.coordinates.x + this.outline/2, 
                    this.coordinates.y + this.outline/2, 
                    this.width - this.outline, 
                    this.height - this.outline, 
                    this.width
                )
                this.ctx.fill()
            }

            getCoordinates = () => this.coordinates

            getInfo = () => ({
                canvasId: this.canvasId, 
                color:  this.color, 
                outline:this.outline, 
                width:  this.width, 
                height: this.height, 
                coordinates: this.coordinates
            })

        }

        function main() {

            // define variables
            const scale = 50
            const canvas = document.querySelector('#canvas')
            const controllerElem = document.querySelector('#controller')
            const random = (min, max, invalidNumbers) => {
                const randomNumber = Math.floor( Math.random() * (max+1 - min) + min )
                return invalidNumbers && invalidNumbers.includes(randomNumber) ? random(min, max, invalidNumbers): randomNumber
            }
            const randomCoordinates = (array) => {
                const x = random(0, screen.getColsCount() - 1)
                const y = random(0, screen.getRowsCount() - 1)
                if ( array.some(i => i.x / scale === x && i.y / scale === y) )
                    return randomCoordinates(array)
                return { x: x * scale, y: y * scale }
            }

            const screen = new Screen({ canvas, controllerElem, scale, fps: 10 })
            window.addEventListener('resize', screen.resize)

            // Snake game
            const configs = {
                processInterval: setInterval(() => {}), 
                snake: new Snake({
                    name: '\'Midgard Serpent\'', 
                    canvasId: canvas.id, 
                    gap: 2, 
                    width: scale, 
                    height: scale, 
                    mainColor: '#FF7700', 
                    spiritColor: '#0077FF44'
                }), 
                food: new Food({
                    canvasId: canvas.id, 
                    color: '#F7F7F7', 
                    outline: 15, 
                    width: scale, 
                    height: scale
                }), 

                init: () => {

                    screen.init()
                    screen.clear()
                    screen.drawGridLines()

                }, 

                start: () => {
                    // spawn snake
                    configs.snake.spawn(randomCoordinates( [] ))
                    // spawn food
                    configs.food.spawn(randomCoordinates( configs.snake.getBody() ))
                    // snake start moving to get the food
                    configs.snake.moveTo(
                        configs.food.getCoordinates(), screen.getColsCount() * screen.getScale(), screen.getRowsCount() * screen.getScale()
                    )
                    configs.process()
                }, 

                process: () => configs.processInterval = setInterval(() => {

                    screen.clear()
                    screen.drawGridLines()

                    if ( configs.snake.bitItself() ) {
                        configs.end()
                    }

                    if ( configs.snake.hasGetFood(configs.food.getCoordinates()) ) {

                        configs.food.respawn(randomCoordinates( configs.snake.getBody() ))
                        configs.snake.moveTo( configs.food.getCoordinates(), screen.getColsCount() * screen.getScale(), screen.getRowsCount() * screen.getScale() )
                        configs.snake.grow( screen.getColsCount() * screen.getScale(), screen.getRowsCount() * screen.getScale() )

                    }

                    // move snake
                    configs.snake.takeStep()

                    // 1. draw snake's path
                    configs.snake.draw('path')
                    // 2. draw food
                    configs.food.draw()
                    // 3. draw snake
                    configs.snake.draw('snake')

                }, (1000 / screen.getFPS()) ), 
                
                end: () => {
                    configs.snake.die()
                }, 

                pause: () => {
                    clearInterval(configs.processInterval)
                }, 

                resume: () => {
                    configs.process()
                }, 

                restart: () => {
                    configs.pause()
                    configs.init()
                    configs.start()
                }, 

                save: () => {
                    const snakeInfo = configs.snake.getInfo()
                    const foodInfo = configs.food.getInfo()
                    localStorage.setItem('snake-game', JSON.stringify({
                        snake: snakeInfo, 
                        food: foodInfo
                    }))
                }, 

                load: () => {
                    try {
                        const info = JSON.parse( localStorage.getItem('snake-game') )
                        if (!info) return
                        // TODO: fix
                        if ( 20 < info.snake.body.length ) {
                            localStorage.removeItem('snake-game')
                            return
                        }

                        configs.snake = new Snake(info.snake)
                        configs.food = new Food(info.food)

                    } catch (err) {
                        localStorage.removeItem('snake-game')
                        console.error(err)
                    }
                }, 

                // update: () => {}, 
            }

            // Game handling
            const game = new Game(configs)
            game.load()
            game.init()
            game.start()
            window.addEventListener('beforeunload', e => {
                game.save()
                e.preventDefault()
                e.returnValue = ''
            })

            } main()

    </script>
<noscript> Your browser does not support JavaScript </noscript>
</body>
</html>